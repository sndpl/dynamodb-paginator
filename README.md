![npm](https://img.shields.io/npm/v/dynamodb-paginator.svg)
![NPM](https://img.shields.io/npm/l/dynamodb-paginator.svg)
![David](https://img.shields.io/david/supersoniko/dynamodb-paginator.svg)
![CircleCI](https://img.shields.io/circleci/build/github/supersoniko/dynamodb-paginator.svg)
[![codecov](https://codecov.io/gh/supersoniko/dynamodb-paginator/branch/master/graph/badge.svg)](https://codecov.io/gh/supersoniko/dynamodb-paginator)

**NOTE**: This pagination library only works on indexes with a range key.

# Usage
Compatible with AWS SDK v2 and v3
```typescript
import { DynamoDB } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocument } from '@aws-sdk/lib-dynamodb';
import { getPaginatedResult, decodeCursor } from 'dynamodb-paginator';

interface User {
    id: string
    name: string
}

const documentClient = DynamoDBDocument.from(new DynamoDB({}));

const limit = 25;
const standardQueryParams = {
    TableName: 'Users',
    Limit: limit,
    KeyConditionExpression: 'id = :id',
    ExpressionAttributeValues: {
        ':id': '1'
    }
};
// Could be a cursor from a previous paginated result
const cursor = undefined;
const paginationParams = decodeCursor(cursor) || standardQueryParams;

const result = await documentClient.query(paginationParams);

// By default the cursors are encoded in base64, but you can supply your own encoding function
const paginatedResult = getPaginatedResult<User>(paginationParams, limit, result);
// Output:
// {
//     data: T[],
//     meta: {
//         limit: number,
//         hasMoreData: boolean,
//         cursor: string,
//         backCursor: string,
//         count: number
//     }
// }
```

## Security disclaimer
It's important to validate that the cursor has been generated by your service before passing it to the DynamoDB. If you don't, this opens a NoSQL vulnerability.
A solution for this is signing/encrypting the cursor with a key. 

Without encrypting the cursor, the partition and range key are also visible to the client consuming the cursor.

If your service offers authentication, it's also wise to validate that the cursor being parsed, was originally generated for that user/session. This is to prevent replay attacks.

### Cursor encryption example
A simplified example of encrypting and decrypting the generated pagination cursor.

It's recommended to encapsulate the secured pagination code in a service, for ease of use.

```javascript
import { randomBytes, createCipheriv, createDecipheriv } from 'crypto';
import { getPaginatedResult, decodeCursor } from 'dynamodb-paginator';

const ENC_KEY = randomBytes(32); // set random encryption key
const IV = randomBytes(16); // set random initialisation vector
const ALGORITHM = 'aes-256-cbc';

const encrypt = ((val) => {
    const cipher = createCipheriv(ALGORITHM, ENC_KEY, IV);
    let encrypted = cipher.update(JSON.stringify(val), 'utf8', 'base64');
    encrypted += cipher.final('base64');

    return encrypted;
});

const decrypt = ((encrypted) => {
    const decipher = createDecipheriv(ALGORITHM, ENC_KEY, IV);
    const decrypted = decipher.update(encrypted, 'base64', 'utf8');

    return JSON.parse((decrypted + decipher.final('utf8')));
});

const limit = 25;
const params = { TableName: 'Users', Limit: limit };
// Example DynamoDB Output
const result = {
    Items:
        [
            { id: 1, email: 'a@example.com' },
            { id: 2, email: 'b@example.com' },
        ],
    Count: 2,
    LastEvaluatedKey: { id: 2 },
};

// Pass a custom encoding function
const paginatedResult = getPaginatedResult(params, limit, result, encrypt);

// Pass a custom decoding function
const decodedCursor = decodeCursor(paginatedResult.meta.cursor, decrypt);

console.log(decodedCursor);
// Output:
// {
//     TableName: 'Users',
//     Limit: 25,
//     ExclusiveStartKey: {id:2},
//     previousKeys: [{id:2}],
//     back: false
// }
```

# API Reference

## Functions

<dl>
<dt><a href="#getPaginatedResult">getPaginatedResult(params, limit, result, cursorEncodingFunction, enableBackNavigation)</a> ⇒ <code>PaginatedResult&lt;T&gt;</code></dt>
<dd></dd>
<dt><a href="#decodeCursor">decodeCursor(encodedCursor, cursorDecodingFunction)</a> ⇒ <code>DynamoDBParams</code> | <code>undefined</code></dt>
<dd></dd>
</dl>

## Typedefs

<dl>
<dt><a href="#DynamoDBParams">DynamoDBParams</a> : <code>Object</code></dt>
<dd></dd>
<dt><a href="#DynamoDBResult">DynamoDBResult</a> : <code>Object</code></dt>
<dd></dd>
<dt><a href="#MetaData">MetaData</a> : <code>Object</code></dt>
<dd></dd>
<dt><a href="#PaginatedResult">PaginatedResult</a> : <code>Object</code></dt>
<dd></dd>
</dl>

<a name="getPaginatedResult"></a>

## getPaginatedResult(params, limit, result) ⇒ <code>PaginatedResult&lt;T&gt;</code>
**Kind**: function

| Param                   | Type                                                               |
|-------------------------|--------------------------------------------------------------------|
| params                  | [<code>DynamoDBParams</code>](#DynamoDBParams)                     |
| limit                   | <code>number</code>                                                |
| result                  | [<code>DynamoDBResult</code>](#DynamoDBResult)                     |
| cursorEncodingFunction? | <code>(cursor: [DynamoDBParams](#DynamoDBParams)) => string</code> |
| enableBackNavigation    | <code>boolean</code>                                               |

<a name="decodeCursor"></a>

## decodeCursor(cursor) ⇒ <code>Cursor</code> \| <code>undefined</code>
**Kind**: function

| Param | Type |
| --- | --- |
| encodedCursor| <code>string</code> |
| cursorDecodingFunction? | <code>(encodedCursor: string) => [DynamoDBParams](#DynamoDBParams)</code> |

<a name="DynamoDBParams"></a>

## DynamoDBParams : <code>Object</code>
**Kind**: object
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| TableName | <code>string</code> | The name of the table containing the requested items |
| [IndexName] | <code>string</code> | The name of a secondary index to scan |
| [AttributesToGet] | <code>any</code> | This is a legacy parameter. Use ProjectionExpression instead. |
| [Limit] | <code>number</code> | The maximum number of items to evaluate |
| [Select] | <code>any</code> | The attributes to be returned in the result |
| [ScanFilter] | <code>any</code> | This is a legacy parameter |
| [ConditionalOperator] | <code>any</code> | This is a legacy parameter |
| [ExclusiveStartKey] | <code>any</code> | The primary key of the first item that this operation will evaluate |
| [ReturnConsumedCapacity] | <code>any</code> | Adds the consumed capacity to the result |
| [TotalSegments] | <code>any</code> | For a parallel Scan request |
| [Segment] | <code>any</code> | For a parallel Scan request |
| [ProjectionExpression] | <code>string</code> | A string that identifies one or more attributes to retrieve from the specified table or index |
| [FilterExpression] | <code>string</code> | A string that contains conditions that DynamoDB applies after the Scan operation |
| [ExpressionAttributeNames] | <code>any</code> | One or more substitution tokens for attribute names in an expression |
| [ExpressionAttributeValues] | <code>any</code> | One or more values that can be substituted in an expression |
| [ConsistentRead] | <code>boolean</code> | A Boolean value that determines the read consistency model during the scan |

<a name="DynamoDBResult"></a>

## DynamoDBResult : <code>Object</code>
**Kind**: object
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [Items] | <code>any</code> | An array of item attributes that match the scan criteria |
| [Count] | <code>number</code> | The number of items in the response |
| [ScannedCount] | <code>number</code> | The number of items evaluated |
| [LastEvaluatedKey] | <code>any</code> | The primary key of the item where the operation stopped |
| [ConsumedCapacity] | <code>any</code> | The capacity units consumed by the Scan operation |

<a name="MetaData"></a>

## MetaData : <code>Object</code>
**Kind**: object
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| limit | <code>number</code> | The limit of the amount of returned items |
| hasMoreData | <code>boolean</code> | True if not all items in the DynamoDB table were returned that match the query |
| cursor | <code>string</code> | Used for pagination if there are more items left |
| backCursor? | <code>string</code> | Used for paginating back to previous results |
| count | <code>number</code> | The amount of items returned |

<a name="PaginatedResult"></a>

## PaginatedResult : <code>Object</code>
**Kind**: object
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| data | <code>T</code> | The queried data |
| meta | [<code>MetaData</code>](#MetaData) | Metadata regarding the result |
